# -*- coding: utf-8 -*-
"""DataScienceDota2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R8drOV2xI6osk-3JIybJsOGavcukp17z
"""

# @title Import bibliotek.
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import math
import warnings

from sklearn.preprocessing import LabelEncoder
from matplotlib import rcParams

# @title Wczytanie zbioru danych
dota2Data = pd.read_csv('/content/data2.csv')
dota2Data.columns = dota2Data.columns.str.strip()
dota2Data.info()
dota2Data.head(100)

# @title Analiza zbioru danych: usunięcie błędnych danych.
dota2_heroes = [
    "Abaddon", "Alchemist", "Ancient Apparition", "Anti-Mage", "Arc Warden", "Axe", "Bane", "Batrider",
    "Beastmaster", "Bloodseeker", "Bounty Hunter", "Brewmaster", "Bristleback", "Broodmother", "Centaur Warrunner",
    "Chaos Knight", "Chen", "Clinkz", "Clockwerk", "Crystal Maiden", "Dark Seer", "Dark Willow", "Dawnbreaker",
    "Dazzle", "Death Prophet", "Disruptor", "Doom", "Dragon Knight", "Drow Ranger", "Earth Spirit", "Earthshaker",
    "Elder Titan", "Ember Spirit", "Enchantress", "Enigma", "Faceless Void", "Grimstroke", "Gyrocopter", "Hoodwink",
    "Huskar", "Invoker", "Io", "Jakiro", "Juggernaut", "Keeper of the Light", "Kunkka", "Legion Commander", "Leshrac",
    "Lich", "Lifestealer", "Lina", "Lion", "Lone Druid", "Luna", "Lycan", "Magnus", "Marci", "Mars", "Medusa", "Meepo",
    "Mirana", "Monkey King", "Morphling", "Muerta", "Naga Siren", "Nature's Prophet", "Necrophos", "Night Stalker",
    "Nyx Assassin", "Ogre Magi", "Omniknight", "Oracle", "Outworld Destroyer", "Pangolier", "Phantom Assassin",
    "Phantom Lancer", "Phoenix", "Primal Beast", "Puck", "Pudge", "Pugna", "Queen of Pain", "Razor", "Riki", "Rubick",
    "Sand King", "Shadow Demon", "Shadow Fiend", "Shadow Shaman", "Silencer", "Skywrath Mage", "Slardar", "Slark",
    "Snapfire", "Sniper", "Spectre", "Spirit Breaker", "Storm Spirit", "Sven", "Techies", "Templar Assassin",
    "Terrorblade", "Tidehunter", "Timbersaw", "Tinker", "Tiny", "Treant Protector", "Troll Warlord", "Tusk",
    "Underlord", "Undying", "Ursa", "Vengeful Spirit", "Venomancer", "Viper", "Visage", "Void Spirit", "Warlock",
    "Weaver", "Windranger", "Winter Wyvern", "Witch Doctor", "Wraith King", "Zeus"
]

hero_columns = [
    'Team_A_Carry_Hero', 'Team_A_Mid_Hero', 'Team_A_Off_Hero', 'Team_A_Support_Hero', 'Team_A_HardSupport_Hero',
    'Team_B_Carry_Hero', 'Team_B_Mid_Hero', 'Team_B_Off_Hero', 'Team_B_Support_Hero', 'Team_B_HardSupport_Hero'
]

dota2_heroes_set = set(h.strip() for h in dota2_heroes)

def is_valid_hero(name):
    if not isinstance(name, str):
        return False
    return name.strip() in dota2_heroes_set

valid_mask = pd.Series([True] * len(dota2Data))

for col in hero_columns:
    valid_mask &= dota2Data[col].apply(is_valid_hero)

dota2Data_cleaned = dota2Data[valid_mask].reset_index(drop=True)
print(f"Usunięto {len(dota2Data) - len(dota2Data_cleaned)} błędnych wierszy.")
dota2Data = dota2Data_cleaned

# @title Analiza zbioru danych: brakujące wartości.
missing_values = dota2Data.isna().sum()
missing_values_df = pd.DataFrame(missing_values, columns=['Liczba brakujących wartości'])
missing_values_df['Procentowa liczba brakujących wartości'] = missing_values_df['Liczba brakujących wartości'] / len(dota2Data) * 100
missing_values_df.style.background_gradient(cmap='viridis')
missing_values_df

# @title Analiza zbioru danych: sprawdzenie duplikatów.
duplicate_count = dota2Data.duplicated().sum()

duplicates_table = pd.DataFrame({
    'Description': ['Number of duplicated rows'],
    'Value': [duplicate_count]})
duplicates_table

duplicate_count = dota2Data.duplicated().sum()
print(f"Liczba wierszy przed usunięciem duplikatów: {len(dota2Data)}")
print(f"Liczba duplikatów: {duplicate_count}")

dota2Data = dota2Data.drop_duplicates()

print(f"Liczba wierszy po usunięciu duplikatów: {len(dota2Data)}")

# @title Analiza zbioru danych: najczęściej grane postacie na danej roli.
hero_columns = {
    'Carry': ['Team_A_Carry_Hero', 'Team_B_Carry_Hero'],
    'Mid': ['Team_A_Mid_Hero', 'Team_B_Mid_Hero'],
    'Offlane': ['Team_A_Off_Hero', 'Team_B_Off_Hero'],
    'Support': ['Team_A_Support_Hero', 'Team_B_Support_Hero'],
    'HardSupport': ['Team_A_HardSupport_Hero', 'Team_B_HardSupport_Hero'],
}

hero_role_data = []
dota2Data.columns = dota2Data.columns.str.strip()

for role, cols in hero_columns.items():
    for col in cols:
        temp_df = dota2Data[[col]].copy()
        temp_df.columns = ['Hero']
        temp_df['Role'] = role
        hero_role_data.append(temp_df)

long_df = pd.concat(hero_role_data, ignore_index=True)
# print(len(long_df))

hero_counts = long_df.groupby(['Role', 'Hero']).size().reset_index(name='Count')

hero_counts_sorted = hero_counts.sort_values(by=['Role', 'Count'], ascending=[True, False])
top_heroes_per_role = hero_counts_sorted.groupby('Role').head(20)


sns.set(style="whitegrid")
roles = top_heroes_per_role['Role'].unique()

n_plots = len(roles)
n_cols = 2
n_rows = math.ceil(n_plots / n_cols)

fig, axes = plt.subplots(nrows=n_rows, ncols=n_cols, figsize=(12, 5 * n_rows), sharey=False)

axes = axes.flatten()

for ax, role in zip(axes, roles):
    subset = top_heroes_per_role[top_heroes_per_role['Role'] == role]
    sns.barplot(x='Count', y='Hero', data=subset, hue='Hero', palette='viridis', legend=False, ax=ax)
    ax.set_title(f"Top 20 bohaterów na roli: {role}")
    ax.set_xlabel(f"Liczba gier (MAX: {len(dota2Data)})")
    ax.set_ylabel("Bohater")

for i in range(len(roles), len(axes)):
    fig.delaxes(axes[i])

plt.tight_layout()
plt.show()

# @title Analiza zbioru danych: najczęściej grane postacie ogólnie.

total_hero_counts = long_df.groupby('Hero').size().reset_index(name='Count')

total_hero_counts_sorted = total_hero_counts.sort_values(by='Count', ascending=False)

top_20_heroes = total_hero_counts_sorted.head(20)
bottom_20_heroes = total_hero_counts_sorted.tail(20).iloc[::-1]

plt.figure(figsize=(10, 6))
sns.barplot(x='Count', y='Hero', data=top_20_heroes, hue='Hero', palette='magma', legend=False)
plt.title("Top 20 najczęściej granych bohaterów")
plt.xlabel("Liczba gier")
plt.ylabel("Bohater")
plt.show()

print("\n")
plt.figure(figsize=(10, 6))
sns.barplot(x='Count', y='Hero', data=bottom_20_heroes, hue='Hero', palette='magma', legend=False)
plt.title("Top 20 najrzadziej granych bohaterów")
plt.xlabel("Liczba gier")
plt.ylabel("Bohater")
plt.show()

plt.tight_layout()
plt.show()

# @title Analiza zbioru danych: najdłuższy, najkrótszy mecz i średnia.
def time_to_seconds(t):
    parts = list(map(int, t.strip().split(":")))
    if len(parts) == 2:
        minutes, seconds = parts
        return minutes * 60 + seconds
    elif len(parts) == 3:
        hours, minutes, seconds = parts
        return hours * 3600 + minutes * 60 + seconds
    else:
        return None

dota2Data['Match_Duration_Seconds'] = dota2Data['Time'].apply(time_to_seconds)

shortest_match = dota2Data['Match_Duration_Seconds'].min()
longest_match = dota2Data['Match_Duration_Seconds'].max()
average_match = dota2Data['Match_Duration_Seconds'].mean()

def format_duration(seconds):
    minutes = int(seconds // 60)
    sec = int(seconds % 60)
    return f"{minutes}m {sec}s"

print("Najkrótszy mecz:", format_duration(shortest_match), f"({shortest_match} sekund)")
print("Najdłuższy mecz:", format_duration(longest_match), f"({longest_match} sekund)")
print("Średni czas trwania meczu:", format_duration(average_match), f"({average_match:.2f} sekund)")

dota2Data['Match_Duration_Minutes'] = dota2Data['Match_Duration_Seconds'] / 60

shortest_match_min = dota2Data['Match_Duration_Minutes'].min()
longest_match_min = dota2Data['Match_Duration_Minutes'].max()
average_match_min = dota2Data['Match_Duration_Minutes'].mean()

plt.figure(figsize=(10, 6))
sns.histplot(dota2Data['Match_Duration_Minutes'], bins=30, kde=True, color='dodgerblue')
plt.axvline(shortest_match_min, color='red', linestyle='--', label='Najkrótszy mecz')
plt.axvline(longest_match_min, color='green', linestyle='--', label='Najdłuższy mecz')
plt.axvline(average_match_min, color='orange', linestyle='--', label='Średni czas meczu')
plt.title('Rozkład długości meczów (w minutach)')
plt.xlabel('Czas trwania meczu (minuty)')
plt.ylabel('Liczba meczów')
plt.legend()
plt.tight_layout()
plt.show()

# @title Analiza zbioru danych: zliczenie tierów.
tier_counts = dota2Data['Tier'].value_counts().sort_index()
for tier in tier_counts.index:
    print(f"Tier {tier}: {tier_counts[tier]} meczów")

plt.figure(figsize=(8, 5))
sns.barplot(x=tier_counts.index, y=tier_counts.values, hue=tier_counts.index, palette='plasma', legend=False)
plt.title('Liczba meczów dla każdego Tieru')
plt.xlabel('Tier')
plt.ylabel('Liczba meczów')
plt.tight_layout()
plt.show()

# @title Analiza zbioru danych: najczęsciej i najrzadziej występujące drużyny dla danego tieru.

teams_tiers = pd.concat([
    dota2Data[['Team_A_Name', 'Tier']].rename(columns={'Team_A_Name': 'Team'}),
    dota2Data[['Team_B_Name', 'Tier']].rename(columns={'Team_B_Name': 'Team'})
], ignore_index=True)

team_tier_counts = teams_tiers.groupby(['Tier', 'Team']).size().reset_index(name='Liczba meczów')

tiers = sorted(team_tier_counts['Tier'].unique())

tiers_list = []
most_common_teams = []
most_common_counts = []
least_common_teams = []
least_common_counts = []

for tier in tiers:
    tier_data = team_tier_counts[team_tier_counts['Tier'] == tier]
    most_common_row = tier_data.loc[tier_data['Liczba meczów'].idxmax()]
    least_common_row = tier_data.loc[tier_data['Liczba meczów'].idxmin()]

    tiers_list.append(tier)
    most_common_teams.append(f"{most_common_row['Team']} (max)")
    most_common_counts.append(most_common_row['Liczba meczów'])
    least_common_teams.append(f"{least_common_row['Team']} (min)")
    least_common_counts.append(least_common_row['Liczba meczów'])

fig, ax = plt.subplots(figsize=(12, 6))

bar_width = 0.4
indices = range(len(tiers_list))

ax.bar(indices, most_common_counts, bar_width, label='Najczęściej występująca drużyna', color='green')
ax.bar([i + bar_width for i in indices], least_common_counts, bar_width, label='Najrzadziej występująca drużyna', color='red')

ax.set_xticks([i + bar_width/2 for i in indices])
ax.set_xticklabels([f"Tier {t}" for t in tiers_list])

ax.set_xlabel('Tier')
ax.set_ylabel('Liczba meczów')
ax.set_title('Najczęściej i najrzadziej występujące drużyny w każdym tierze')

for i in indices:
    ax.text(i, most_common_counts[i] + 1, most_common_teams[i], ha='center', color='green', fontsize=8, rotation=30)
    ax.text(i + bar_width, least_common_counts[i] + 1, least_common_teams[i], ha='center', color='red', fontsize=8, rotation=30)

ax.legend()
plt.tight_layout()
plt.show()

print("\n")
num_tiers = len(tiers)
fig, axes = plt.subplots(num_tiers, 1, figsize=(14, 5 * num_tiers), constrained_layout=True)

if num_tiers == 1:
    axes = [axes]

for i, tier in enumerate(tiers):
    tier_data = team_tier_counts[team_tier_counts['Tier'] == tier]
    top_10 = tier_data.sort_values(by='Liczba meczów', ascending=False).head(10)

    axes[i].barh(top_10['Team'][::-1], top_10['Liczba meczów'][::-1], color='dodgerblue')
    axes[i].set_title(f'Top 10 najczęściej granych drużyn - Tier {tier}')
    axes[i].set_xlabel('Liczba meczów')
    axes[i].set_ylabel('Drużyna')

plt.show()

# @title Analiza zbioru danych: najczęsciej grający gracze.

players_columns = [
    'Team_A_Carry_Name', 'Team_A_Mid_Name', 'Team_A_Off_Name', 'Team_A_Support_Name', 'Team_A_HardSupport_Name',
    'Team_B_Carry_Name', 'Team_B_Mid_Name', 'Team_B_Off_Name', 'Team_B_Support_Name', 'Team_B_HardSupport_Name'
]

players_list = [dota2Data[col] for col in players_columns]
all_players = pd.concat(players_list, ignore_index=True)

player_counts = all_players.value_counts()

player_counts = all_players.value_counts()

top_20_players = player_counts.head(20)

plt.figure(figsize=(14, 6))
sns.barplot(x=top_20_players, y=top_20_players.index[::-1], hue=top_20_players, palette="Blues_d", legend=False)
plt.title("Top 20 najczęściej grających graczy")
plt.xlabel("Liczba meczów")
plt.ylabel("Gracz")
plt.tight_layout()
plt.show()

# @title Przygotowanie zbioru do ML: dodanie kolumny "wygra" i usunięcie kolumn typu "status" i "time"
def get_winner(row):
    a_status = str(row['Team_A_Status']).strip().lower()
    b_status = str(row['Team_B_Status']).strip().lower()

    if a_status == 'win' and b_status == 'loss':
        return 0
    elif a_status == 'loss' and b_status == 'win':
        return 1
    else:
        return -1

dota2Data['Wygral'] = dota2Data.apply(get_winner, axis=1)

print(dota2Data[['Team_A_Status', 'Team_B_Status', 'Wygral']].head(55))
dota2Data.drop(columns=['Team_A_Status', 'Team_B_Status', 'Time'], inplace=True)
dota2Data.info()